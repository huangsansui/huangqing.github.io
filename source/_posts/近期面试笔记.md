---
title: 近期面试笔记
date: 2018-04-27 19:26:24
tags: 
    - 面试
    - Java
categories:
    - 面试
---

裸辞离开了毕业后的一个公司，也离开了成都，毅然来到杭州，面试了几家公司，感觉自己有了一点的进步但同时又觉得以前的不够努力所以还落后很多。写下面试中遇到的一些问题，时刻告诉自己：小子，你离目标还远着呢。同时也给自己今后的学习带来一些方向。

<!-- More -->

1.java 八大基本数据类型
byte char short int  long float double boolean
低级->高级：隐式转换
高级->低级: 显si转换 强转

2.short s = 1；s = s+ 1；s += 1;????????这两种写法有什么区别？

3.ssh 和 ssm的区别？

4.Struts2和SpringMVC是单例还是多例，为什么？

5.java多线程(同步 死锁)

6.数据库优化，SQL优化
重构表：固定字段的长度，尽量不为空，表字段太多考虑分表
sql优化：尽量少使用函数，少用*，使用limit
索引的优化：
•只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引
•尽量使用短索引，如果可以，应该制定一个前缀长度
•对于经常在where子句使用的列，最好设置索引，这样会加快查找速度
•对于有多个列where或者order by子句的，应该建立复合索引
•对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引
•尽量不要在列上进行运算（函数操作和表达式操作）
•尽量不要使用not in和<>操作

7.java 序列化和反序列化

8.集合问题
常见的List: ArrayList LinkedList区别，底层实现。
常见的Map:  HashMap TreeMap区别，底层实现。

9.经典sql：
表名：购物信息
购物人 商品名称 数量
A 甲 2
B 乙 4
C 丙 1
A 丁 2
B 丙 5
给出所有购入商品为两种或两种以上的购物人记录；

答案:SELECT 购物人
FROM table
GROUP BY 购物人
HAVING COUNT(DISTINCT 商品名称) >= 2

SELECT * from purchase as p where p.user_name in (SELECT d.user_name from purchase as d GROUP BY d.user_name having count(d.user_name) >= 2)

SELECT `name`,avg(price) FROM `product` GROUP BY `name` HAVING avg(price) < 2;

函数：sum() avg() count() min() max() limit distinct(去重)

10.HashMap和HashTable区别？
从线程安全，null存值上

11.谈谈java有哪些锁?

12.谈谈spring aop

13.Spring Mvc 工作流程

14.jdbc链接数据库

15.servlet生命周期 什么时候初始化?  什么时候销毁?

16.token身份认证实现

17.支付时的并发场景，保证金额的正确性

18.快速排序
```java
package com.quicksort;  
  
import java.util.Arrays;  
  
public class QuickSort {  
    public static void main(String[] args) {  
        int[] a = {1, 2, 4, 5, 7, 4, 5 ,3 ,9 ,0};  
        System.out.println(Arrays.toString(a));  
        quickSort(a);  
        System.out.println(Arrays.toString(a));  
    }  
  
    public static void quickSort(int[] a) {  
        if(a.length>0) {  
            quickSort(a, 0 , a.length-1);  
        }  
    }  
  
    private static void quickSort(int[] a, int low, int high) {  
        //1,找到递归算法的出口  
        if( low > high) {  
            return;  
        }  
        //2, 存  
        int i = low;  
        int j = high;  
        //3,key  
        int key = a[ low ];  
        //4，完成一趟排序  
        while( i< j) {  
            //4.1 ，从右往左找到第一个小于key的数  
            while(i<j && a[j] > key){  
                j--;  
            }  
            // 4.2 从左往右找到第一个大于key的数  
            while( i<j && a[i] <= key) {  
                i++;  
            }  
            //4.3 交换  
            if(i<j) {  
                int p = a[i];  
                a[i] = a[j];  
                a[j] = p;  
            }  
        }  
        // 4.4，调整key的位置  
        int p = a[i];  
        a[i] = a[low];  
        a[low] = p;  
        //5, 对key左边的数快排  
        quickSort(a, low, i-1 );  
        //6, 对key右边的数快排  
        quickSort(a, i+1, high);  
    }  
```
19.归并排序
```java
    public static int[] sort(int[] a,int low,int high){
        int mid = (low+high)/2;
        if(low<high){
            sort(a,low,mid);
            sort(a,mid+1,high);
            //左右归并
            merge(a,low,mid,high);
        }
        return a;
    }
     
    public static void merge(int[] a, int low, int mid, int high) {
        int[] temp = new int[high-low+1];
        int i= low;
        int j = mid+1;
        int k=0;
        // 把较小的数先移到新数组中
        while(i<=mid && j<=high){
            if(a[i]<a[j]){
                temp[k++] = a[i++];
            }else{
                temp[k++] = a[j++];
            }
        }
        // 把左边剩余的数移入数组 
        while(i<=mid){
            temp[k++] = a[i++];
        }
        // 把右边边剩余的数移入数组
        while(j<=high){
            temp[k++] = a[j++];
        }
        // 把新数组中的数覆盖nums数组
        for(int x=0;x<temp.length;x++){
            a[x+low] = temp[x];
        }
    }

```
20.观察者模式，单例模式

21.sql:
  表 员工 uid uname did(部门id)
  表 部门 did dname pid（父部门id）
  部门是一个树状形式的结构（顶级部门的pid为null），查询每个部门（顶级部门）有多少人？
  部门表新增 xid（部门分类） 
  销售部 xid 0001
  销售部A组 xid 00010001
  销售部B组 xid 00010002
  技术部 xid 0002
  技术部A组 xid 00020001
  技术部A组的第一分队 000200010001

22.for和foreach效率问题，当循环次数超过1000000次时，哪个效率高？
  foreach，内部自带迭代器.

23.arraylist扩容过程

24.为什么hashtable效率不高，可以用什么代替？
  为保证线程安全，会使用synchronized关键字。用ConcurrentHashMap代替。

  ConcurrentHashMap能完全替代HashTable吗？
  回答：hash table虽然性能上不如ConcurrentHashMap，但并不能完全被取代，两者的迭代器的一致性不同的，hash table的迭代器是强一致性的，而concurrenthashmap是弱一致的。 ConcurrentHashMap的get，clear，iterator 都是弱一致性的。 Doug Lea 也将这个判断留给用户自己决定是否使用ConcurrentHashMap。
  ConcurrentHashMap的锁分段技术
     HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

25.静态执行顺序

26.sql优化，删除一周以前的日志信息
  原sql: delete * from logs where create_time < '2015-12-05'
  找一个点，确保不扫描全表。例如 id是一个递增的，做索引， where id > 200123


